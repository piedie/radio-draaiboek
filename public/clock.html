<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Radio Klok - Fullscreen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {}
        }
      }
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #111;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      }
    </style>
  </head>
  <body class="bg-black text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div id="clock-container" class="text-center max-w-7xl w-full">
      <div class="text-6xl font-mono font-bold mb-8" id="time-display">
        00:00:00 / 01:00:00
      </div>
      <div class="text-2xl mb-8" id="total-display">
        Totaal: 00:00:00
      </div>
      
      <div class="flex gap-8 items-start justify-center">
        <!-- Clock -->
        <div class="flex-shrink-0">
          <svg id="clock-svg" width="600" height="600" class="mx-auto">
            <!-- Clock will be drawn here -->
          </svg>
          <div class="text-xl mt-4" id="status-display">
            ‚è∏Ô∏è Gestopt
          </div>
        </div>
        
        <!-- Items list -->
        <div class="w-96 max-h-96 overflow-y-auto bg-gray-800 rounded-lg p-4">
          <h3 class="text-xl font-bold mb-4 text-white">üìª Rundown Items</h3>
          <div id="items-list" class="space-y-2">
            <!-- Items will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <script>
      let clockData = {
        items: [],
        currentTime: 0,
        isPlaying: false,
        totalDuration: 0
      };

      // Listen for localStorage changes and load initial data
      function loadClockData() {
        try {
          const saved = localStorage.getItem('radio-clock-state');
          if (saved) {
            const data = JSON.parse(saved);
            // Check if data is recent (within last 10 seconds for better reliability)
            if (Date.now() - data.timestamp < 10000) {
              const prevItemsLength = clockData.items?.length || 0;
              clockData = {
                currentTime: data.currentTime || 0,
                isPlaying: data.isPlaying || false,
                totalDuration: data.totalDuration || 0,
                items: data.items || []
              };
              
              // Debug logging when items change
              if (clockData.items.length !== prevItemsLength) {
                console.log('üîÑ Items updated in external clock:', clockData.items.length, 'items');
              }
            }
          }
        } catch (error) {
          console.error('Error loading clock data:', error);
        }
      }

      // Poll localStorage for updates with higher frequency for smoother updates
      let lastUpdateTime = 0;
      let lastItemsUpdate = 0;
      
      function pollClockData() {
        const prevItems = JSON.stringify(clockData.items);
        loadClockData();
        
        // Check if items changed
        const itemsChanged = prevItems !== JSON.stringify(clockData.items);
        
        // Only update display if data changed or if playing (for smooth seconds)
        const now = Date.now();
        if (clockData.isPlaying || itemsChanged || now - lastUpdateTime > 500) {
          updateClock();
          lastUpdateTime = now;
        }
        
        // Update items more frequently when playing
        if (itemsChanged || (clockData.isPlaying && now - lastItemsUpdate > 100)) {
          updateItemsList();
          lastItemsUpdate = now;
        }
        
        requestAnimationFrame(pollClockData);
      }
      
      // Start polling with animation frame for smooth updates
      pollClockData();

      // Load initial data
      loadClockData();

      // Legacy: Listen for messages from parent window (fallback)
      window.addEventListener('message', (event) => {
        if (event.data.type === 'CLOCK_UPDATE') {
          clockData = event.data.data;
          updateClock();
        }
      });

      function formatTime(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return h + ':' + (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
      }

      function updateClock() {
        // Update time display
        document.getElementById('time-display').textContent = 
          `${formatTime(clockData.currentTime)} / ${formatTime(3600)}`;
        
        // Update total display
        const totalText = `Totaal: ${formatTime(clockData.totalDuration)}`;
        if (clockData.totalDuration > 3600) {
          document.getElementById('total-display').innerHTML = 
            totalText + `<span style="color: #ef4444; margin-left: 1rem;">(+${formatTime(clockData.totalDuration - 3600)} over)</span>`;
        } else {
          document.getElementById('total-display').textContent = totalText;
        }

        // Update status
        document.getElementById('status-display').textContent = 
          clockData.isPlaying ? '‚ñ∂Ô∏è Afspelen' : '‚è∏Ô∏è Gestopt';

        // Draw clock (always update for visual feedback)
        drawClock();
      }

      function updateItemsList() {
        const itemsList = document.getElementById('items-list');
        itemsList.innerHTML = '';
        
        let cumulativeTime = 0;
        clockData.items.forEach((item, index) => {
          const itemDiv = document.createElement('div');
          const isActive = clockData.currentTime >= cumulativeTime && clockData.currentTime < cumulativeTime + item.duration;
          
          itemDiv.className = `p-3 rounded-lg border-l-4 ${isActive ? 'bg-blue-900 border-blue-400' : 'bg-gray-700 border-gray-500'}`;
          itemDiv.style.borderLeftColor = item.color;
          
          const typeEmoji = {
            music: 'üéµ',
            talk: 'üéôÔ∏è', 
            reportage: '‚≠ê',
            live: 'üì°',
            game: 'üéÆ',
            jingle: 'üîî'
          };
          
          itemDiv.innerHTML = `
            <div class="flex justify-between items-start">
              <div class="flex-1">
                <div class="font-semibold text-white flex items-center gap-2">
                  ${typeEmoji[item.type] || 'üìÑ'} ${item.title}
                </div>
                ${item.artist ? `<div class="text-gray-300 text-sm">${item.artist}</div>` : ''}
                <div class="text-gray-400 text-xs">
                  ${formatTimeShort(item.duration)} | ${formatTime(cumulativeTime)} - ${formatTime(cumulativeTime + item.duration)}
                </div>
              </div>
            </div>
          `;
          
          itemsList.appendChild(itemDiv);
          cumulativeTime += item.duration;
        });
      }

      function formatTimeShort(seconds) {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return m + ':' + (s < 10 ? '0' : '') + s;
      }

      function drawClock() {
        const svg = document.getElementById('clock-svg');
        const radius = 280;
        const center = 300;
        const hourDuration = 3600;
        
        // Clear previous content
        svg.innerHTML = '';

        // Draw segments with titles
        let acc = 0;
        clockData.items.forEach((item, index) => {
          const start = acc;
          const end = acc + item.duration;
          if (start >= hourDuration) return;
          
          const dur = Math.min(item.duration, hourDuration - start);
          const angle = (dur / hourDuration) * 360;
          const startA = (start / hourDuration) * 360 - 90;
          const startRad = startA * Math.PI / 180;
          const endRad = (startA + angle) * Math.PI / 180;
          
          const x1 = center + radius * Math.cos(startRad);
          const y1 = center + radius * Math.sin(startRad);
          const x2 = center + radius * Math.cos(endRad);
          const y2 = center + radius * Math.sin(endRad);
          
          const largeArc = angle > 180 ? 1 : 0;
          const path = `M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
          
          const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          pathElement.setAttribute('d', path);
          pathElement.setAttribute('fill', end > hourDuration ? '#dc2626' : item.color);
          pathElement.setAttribute('stroke', '#374151');
          pathElement.setAttribute('stroke-width', '2');
          pathElement.setAttribute('opacity', '0.8');
          svg.appendChild(pathElement);
          
          // Add title text in segment if segment is large enough
          if (angle > 15) { // Only show text for segments larger than 15 degrees
            const midAngle = startA + angle / 2;
            const midRad = midAngle * Math.PI / 180;
            const textRadius = radius * 0.7; // Position text at 70% of radius
            const textX = center + textRadius * Math.cos(midRad);
            const textY = center + textRadius * Math.sin(midRad);
            
            // Create text element
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', textX);
            text.setAttribute('y', textY);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('class', 'text-xs font-bold fill-white drop-shadow-lg');
            text.setAttribute('transform', `rotate(${midAngle + 90}, ${textX}, ${textY})`);
            
            // Truncate title if too long
            let displayTitle = item.title;
            if (displayTitle.length > 12) {
              displayTitle = displayTitle.substring(0, 10) + '...';
            }
            
            text.textContent = displayTitle;
            svg.appendChild(text);
          }
          
          acc += item.duration;
        });

        // Draw time markers
        [0, 15, 30, 45].forEach(min => {
          const a = (min / 60) * 360 - 90;
          const rad = a * Math.PI / 180;
          
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', center + (radius - 30) * Math.cos(rad));
          line.setAttribute('y1', center + (radius - 30) * Math.sin(rad));
          line.setAttribute('x2', center + radius * Math.cos(rad));
          line.setAttribute('y2', center + radius * Math.sin(rad));
          line.setAttribute('stroke', '#6b7280');
          line.setAttribute('stroke-width', '4');
          svg.appendChild(line);
          
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', center + (radius + 40) * Math.cos(rad));
          text.setAttribute('y', center + (radius + 40) * Math.sin(rad));
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('class', 'text-2xl font-bold fill-white');
          text.textContent = min;
          svg.appendChild(text);
        });

        // Draw hand
        const currAngle = (clockData.currentTime / hourDuration) * 360 - 90;
        const currRad = currAngle * Math.PI / 180;
        const handX = center + (radius - 20) * Math.cos(currRad);
        const handY = center + (radius - 20) * Math.sin(currRad);
        
        const hand = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        hand.setAttribute('x1', center);
        hand.setAttribute('y1', center);
        hand.setAttribute('x2', handX);
        hand.setAttribute('y2', handY);
        hand.setAttribute('stroke', '#fff');
        hand.setAttribute('stroke-width', '6');
        svg.appendChild(hand);
        
        const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        centerDot.setAttribute('cx', center);
        centerDot.setAttribute('cy', center);
        centerDot.setAttribute('r', '12');
        centerDot.setAttribute('fill', '#fff');
        svg.appendChild(centerDot);
      }

      // Initial empty state
      updateClock();

      // Request data from parent window if it exists
      if (window.opener) {
        window.opener.postMessage({ type: 'CLOCK_WINDOW_READY' }, '*');
      }
    </script>
  </body>
</html>
